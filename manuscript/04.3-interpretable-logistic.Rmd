```{r, message = FALSE, warning = FALSE, echo = FALSE}
devtools::load_all()
set.seed(42)
```

<!--{pagebreak}-->

<!--
## Logistic Regression {#logistic}
-->
## ロジスティック回帰 {#logistic}

<!--
Logistic regression models the probabilities for classification problems with two possible outcomes.
It's an extension of the linear regression model for classification problems.
-->
ロジスティック回帰は2つの可能な結果を伴う分類問題の確率をモデル化します。これは線形回帰モデルの分類問題への拡張です。

<!--
### What is Wrong with Linear Regression for Classification?
-->
### 線形回帰モデルを分類のために使うと何がいけないか。

<!--
The  linear regression model can work well for regression, but fails for classification.
Why is that?
In case of two classes, you could label one of the classes with 0 and the other with 1 and use linear regression.
Technically it works and most linear model programs will spit out weights for you.
But there are a few problems with this approach:

A linear model does not output probabilities, but it treats the classes as numbers (0 and 1) and fits the best hyperplane (for a single feature, it is a line) that minimizes the distances between the points and the hyperplane.
So it simply interpolates between the points, and you cannot interpret it as probabilities.

A linear model also extrapolates and gives you values below zero and above one.
This is a good sign that there might be a smarter approach to classification.

Since the predicted outcome is not a probability, but a linear interpolation between points, there is no meaningful threshold at which you can distinguish one class from the other.
A good illustration of this issue has been given on [Stackoverflow](https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression).

Linear models do not extend to classification problems with multiple classes.
You would have to start labeling the next class with 2, then 3, and so on.
The classes might not have any meaningful order, but the linear model would force a weird structure on the relationship between the features and your class predictions.
The higher the value of a feature with a positive weight, the more it contributes to the prediction of a class with a higher number, even if classes that happen to get a similar number are not closer than other classes.
-->
線形回帰モデルは回帰問題ではうまく働きますが、分類問題ではうまくいきません。
なぜでしょうか？
2クラス分類の場合、あるクラスを 0、もう一方を 1 とラベル付けし、線形回帰モデルを使ったとしましょう。
技術的にはうまく働き、線形モデルは重みを計算します。
しかし、この方法にはいくらか問題があります。

線形モデルは確率を出力せず、クラスを数字として扱い、点との距離を最小化するような最適な超平面に (単一の特徴量に対しては線として) 適合させます。
それは、単に、点の間の補間をしているだけなので、確率として解釈できません。

また、線形モデルは外挿し、0 より小さかったり、1 より大きな値を出力します。
これは分類問題に対する、より良いアプローチがあるかもしれないというよい徴候です。

予測結果が確率ではなく、点の間の線形補間なので、クラスを分けるための、意味のある閾値というものは存在しません。
この問題に関するわかりやすい説明は[Stackoverflow](https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression) に示されています。

線形モデルは多クラス分類には拡張できません。
次のクラスを 2 だったり、3 だったりとラベル付けするかもしれません。
クラスの順序に意味のないときもあるでしょうが、線形モデルにおいては特徴量と予測クラスに不自然な関係性を作ることが強制されます。
同じような値に偶然なったクラスが他のクラスと近くなかったとしても、正の重みをもつ特徴量の値が高ければ高いほど、予測されるクラスはより大きな数になりやすくなっていきます。

<!--
fig.cap="A linear model classifies tumors as malignant (1) or benign (0) given their size. The lines show the prediction of the linear model. For the data on the left, we can use 0.5 as classification threshold. After introducing a few more malignant tumor cases, the regression line shifts and a threshold of 0.5 no longer separates the classes. Points are slightly jittered to reduce over-plotting. "
-->
```{r linear-class-threshold, fig.cap="線形モデルで大きさによって腫瘍が良性であるか、悪性であるか分類しています。直線は線形モデルの予測を表しています。左にあるデータでは 0.5 を閾値として用いています。いくつか悪性のケースが入った場合では、回帰直線はシフトし、0.5 はもはや閾値としては機能しなくなっています。表示する点を少しだけ減らして、見やすくしています。"}
library("ggplot2")
df = data.frame(x = c(1,2,3,8,9,10,11,9),
  y = c(0,0,0,1,1,1,1, 0),
  case = '0.5 threshold ok')

df_extra  = data.frame(x=c(df$x, 7, 7, 7, 20, 19, 5, 5, 4, 4.5),
  y=c(df$y, 1,1,1,1, 1, 1, 1, 1, 1),
  case = '0.5 threshold not ok')

df.lin.log = rbind(df, df_extra)
p1 = ggplot(df.lin.log, aes(x=x,y=y)) +
  geom_point(position = position_jitter(width=0, height=0.02)) +
  geom_smooth(method='lm', se=FALSE) +
  my_theme() +
  scale_y_continuous('', breaks = c(0, 0.5, 1), labels = c('benign tumor', '0.5',  'malignant tumor'), limits = c(-0.1,1.3)) +
  scale_x_continuous('Tumor size') +
  facet_grid(. ~ case) +
  geom_hline(yintercept=0.5, linetype = 3)

p1
```

<!--
### Theory
-->
### 理論

<!--
A solution for classification is logistic regression.
Instead of fitting a straight line or hyperplane, the logistic regression model uses the logistic function to squeeze the output of a linear equation between 0 and 1.
The logistic function is defined as:
-->
分類のための解決策は、ロジスティック回帰です。
直線や超平面を当てはめる代わりに、ロジスティック回帰モデルでは、ロジスティック関数を使用して、0 と 1 の間へ線形方程式の出力を変形します。
ロジスティック関数は次のように定義されます。

$$\text{logistic}(\eta)=\frac{1}{1+exp(-\eta)}$$

<!--
And it looks like this:
-->
下図のようになります。

<!--
fig.cap="The logistic function. It outputs numbers between 0 and 1. At input 0, it outputs 0.5."
-->
```{r, logistic-function, fig.cap="ロジスティック関数。 出力は 0 から 1 の間を取ります。 入力が 0 のとき、出力は 0.5 です。"}
logistic = function(x){1 / (1 + exp(-x))}

x = seq(from=-6, to = 6, length.out = 100)
df = data.frame(x = x,
  y = logistic(x))
ggplot(df) + geom_line(aes(x=x,y=y)) + my_theme()
```

<!--
The step from linear regression to logistic regression is kind of straightforward.
In the linear regression model, we have modelled the relationship between outcome and features with a linear equation:
-->
線形回帰からロジスティック回帰への変換は理解しやすいです。
線形回帰モデルでは、結果と特徴量の関係を線形方程式でモデル化しています。

$$\hat{y}^{(i)}=\beta_{0}+\beta_{1}x^{(i)}_{1}+\ldots+\beta_{p}x^{(i)}_{p}$$

<!--
For classification, we prefer probabilities between 0 and 1, so we wrap the right side of the equation into the logistic function.
This forces the output to assume only values between 0 and 1.
-->
分類において、値が 0 から 1 の間となるように、右式をロジスティック関数に組み込みます。
この変換によって、出力は 0 から 1 の間の値を取るようにできます。

$$P(y^{(i)}=1)=\frac{1}{1+exp(-(\beta_{0}+\beta_{1}x^{(i)}_{1}+\ldots+\beta_{p}x^{(i)}_{p}))}$$

<!--
Let us revisit the tumor size example again.
But instead of the linear regression model, we use the logistic regression model:
-->
腫瘍の大きさの例をもう一度見てみましょう。
線形回帰モデルの代わりにロジスティック回帰モデルを使っています。

<!--
fig.cap="The logistic regression model finds the correct decision boundary between malignant and benign depending on tumor size. The line is the logistic function shifted and squeezed to fit the data."
-->
```{r logistic-class-threshold, fig.cap="ロジスティック回帰モデルは、腫瘍のサイズに応じて、悪性と良性の間の正しい決定境界を見つけます。 この線は、データに適合するように変形されたロジスティック関数です。"}
logistic1 = glm(y ~ x, family = binomial, data = df.lin.log[df.lin.log$case == '0.5 threshold ok',])
logistic2 = glm(y ~ x, family = binomial, data = df.lin.log)

lgrid = data.frame(x = seq(from=0, to=20, length.out=100))
lgrid$y1_pred = predict(logistic1, newdata = lgrid, type='response')
lgrid$y2_pred = predict(logistic2 , newdata = lgrid, type='response')
lgrid.m = data.frame(data.table::melt(lgrid, measure.vars = c("y1_pred", "y2_pred")))
colnames(lgrid.m) = c("x", "case", "value")
lgrid.m$case = as.character(lgrid.m$case)
lgrid.m$case[lgrid.m$case == "y1_pred"] = '0.5 threshold ok'
lgrid.m$case[lgrid.m$case == "y2_pred"] = '0.5 threshold ok as well'
df.lin.log$case = as.character(df.lin.log$case)
df.lin.log$case[df.lin.log$case == "0.5 threshold not ok"] = '0.5 threshold ok as well'



p1 = ggplot(df.lin.log, aes(x=x,y=y)) +
  geom_line(aes(x=x, y=value), data = lgrid.m, color='blue', size=1) +
  geom_point(position = position_jitter(width=0, height=0.02)) +
  my_theme() +
  scale_y_continuous('Tumor class', breaks = c(0, 0.5, 1), labels = c('benign tumor', '0.5',  'malignant tumor'), limits = c(-0.1,1.3)) +
  scale_x_continuous('Tumor size') +
  facet_grid(. ~ case) +
  geom_hline(yintercept=0.5, linetype = 3)

p1
```

<!--
Classification works better with logistic regression and we can use 0.5 as a threshold in both cases. The inclusion of additional points does not really affect the estimated curve.
-->
ロジスティック回帰はうまく分類し、両方のケースで 0.5 を閾値として使うことができます。点を追加することは、推定された曲線にそこまで影響を与えません。

<!--
### Interpretation
-->
### 解釈性

<!--
The interpretation of the weights in logistic regression differs from the interpretation of the weights in linear regression, since the outcome in logistic regression is a probability between 0 and 1.
The weights do not influence the probability linearly any longer.
The weighted sum is transformed by the logistic function to a probability.
Therefore we need to reformulate the equation for the interpretation so that only the linear term is on the right side of the formula.
-->
ロジスティック回帰モデルの出力は 0 から 1 の確率で表現されるため、ロジスティック回帰の重みの解釈は線形回帰モデルの重みの解釈とは異なります。
重みは確率に対して、線形に影響を及ぼすわけではありません。
重みの合計はロジスティック関数によって確率に変換されます。
したがって、解釈のために、方程式の右側の線形項を式変形する必要があります。

$$log\left(\frac{P(y=1)}{1-P(y=1)}\right)=log\left(\frac{P(y=1)}{P(y=0)}\right)=\beta_{0}+\beta_{1}x_{1}+\ldots+\beta_{p}x_{p}$$

<!--
We call the term in the log() function "odds" (probability of event divided by probability of no event) and wrapped in the logarithm it is called log odds.

This formula shows that the logistic regression model is a linear model for the log odds.
Great!
That does not sound helpful!
With a little shuffling of the terms, you can figure out how the prediction changes when one of the features $x_j$ is changed by 1 unit.
To do this, we can first apply the exp() function to both sides of the equation:
-->
この log()関数の中の項を "オッズ" (イベントの確率をイベントが起こらない確率で割ったもの) といい、対数をとったものを対数オッズといいます。

この式はロジスティック回帰モデルが対数オッズに対する線形モデルであることを表しています。
すばらしい！
それでは役に立つようには見えません。
少し項を入れ替えると、特徴量 $x_j$ の1つを 1 単位変化した時、どのように予測が変化するか分かります。
このように変換すると、exp() 関数を方程式の両辺にかけることができます。

$$\frac{P(y=1)}{1-P(y=1)}=odds=exp\left(\beta_{0}+\beta_{1}x_{1}+\ldots+\beta_{p}x_{p}\right)$$

<!--
Then we compare what happens when we increase one of the feature values by 1.
But instead of looking at the difference, we look at the ratio of the two predictions:
-->
そして、1つの特徴量の値を 1 増加させると何が起きるかを比較します。
このとき、差をみるのではなく、2つの予測の比に注目します。

$$\frac{odds_{x_j+1}}{odds}=\frac{exp\left(\beta_{0}+\beta_{1}x_{1}+\ldots+\beta_{j}(x_{j}+1)+\ldots+\beta_{p}x_{p}\right)}{exp\left(\beta_{0}+\beta_{1}x_{1}+\ldots+\beta_{j}x_{j}+\ldots+\beta_{p}x_{p}\right)}$$

<!--
We apply the following rule:
-->
以下のルールを適用します。

$$\frac{exp(a)}{exp(b)}=exp(a-b)$$ 

<!--
And we remove many terms:
-->
そして、項を削除します。

$$\frac{odds_{x_j+1}}{odds}=exp\left(\beta_{j}(x_{j}+1)-\beta_{j}x_{j}\right)=exp\left(\beta_j\right)$$

<!--
In the end, we have something as simple as exp() of a feature weight.
A change in a feature by one unit changes the odds ratio (multiplicative) by a factor of $\exp(\beta_j)$.
We could also interpret it this way:
A change in $x_j$ by one unit increases the log odds ratio by the value of the corresponding weight.
Most people interpret the odds ratio because thinking about the log() of something is known to be hard on the brain.
Interpreting the odds ratio already requires some getting used to.
For example, if you have odds of 2, it means that the probability for y=1 is twice as high as y=0.
If you have a weight (= log odds ratio) of 0.7, then increasing the respective feature by one unit multiplies the odds by exp(0.7) (approximately 2) and the odds change to 4.
But usually you do not deal with the odds and interpret the weights only as the odds ratios.
Because for actually calculating the odds you would need to set a value for each feature, which only makes sense if you want to look at one specific instance of your dataset.
-->
最終的に、特徴量の重みの exp() のような単純な式を得ることができます。
特徴量の中の 1 単位の変化は、オッズ比を $\exp(\beta_j)$ 倍に変化させます。
この式は以下のように解釈できます。
$x_j$ を 1 単位だけ変化させると、対応する重みの値だけ対数オッズ比が増加します。
ほとんどの人は、対数について頭で考えることが困難なため、オッズ比を解釈します。
オッズ比を解釈するには慣れが必要です。
例えば、もしオッズ比として 2 が与えられたら、 y=0 の確率より y=1 の方が 2 倍高いことを意味します。
重み（=対数オッズ比）が 0.7 の場合、それに対応する特徴量を 1 単位増やすと、オッズに exp(0.7)（=約 2）が乗算され、オッズは4に変わります。
しかし、通常はオッズを扱う必要がなく、重みだけをオッズ比として解釈します。
オッズを実際に計算するためには、それぞれの特徴量に値を設定する必要があるためです。
これは、データセットの特定のインスタンスに注目したいときのみ意味を成します。

<!--
These are the interpretations for the logistic regression model with different feature types:
-->
特徴量の種類に応じて、ロジスティック回帰の解釈は異なります。

<!--
- Numerical feature:
If you increase the value of feature $x_{j}$ by one unit, the estimated odds change by a factor of $\exp(\beta_{j})$
- Binary categorical feature:
One of the two values of the feature is the reference category (in some languages, the one encoded in 0).
Changing the feature $x_{j}$ from the reference category to the other category changes the estimated odds by a factor of $\exp(\beta_{j})$.
- Categorical feature with more than two categories:
One solution to deal with multiple categories is one-hot-encoding, meaning that each category has its own column.
You only need L-1 columns for a categorical feature with L categories, otherwise it is over-parameterized.
The L-th category is then the reference category.
You can use any other encoding that can be used in linear regression.
The interpretation for each category then is equivalent to the interpretation of binary features.
- Intercept $\beta_{0}$:
When all numerical features are zero and the categorical features are at the reference category, the estimated odds are $\exp(\beta_{0})$.
The interpretation of the intercept weight is usually not relevant.
-->
- 数的特徴量 (Numerical feature)の場合:
$x_{j}$ を 1 単位だけ増加させると、予測されるオッズは $\exp(\beta_{j})$ 倍に変化します。
- バイナリ特徴量 (Binary categorical feature) の場合:
特徴量の2つの値のうちの1つは 参照カテゴリ (いくつかのプログラミング言語では、0 とエンコードされる) です。
特徴量 $x_{j}$ が参照カテゴリから他のカテゴリに変化した時、オッズは $\exp(\beta_{j})$ 倍になります。
- 2つ以上のカテゴリを持つ、カテゴリカルデータの場合:
複数のカテゴリを扱う1つの方法は one-hot-encoding です。one-hot-encoding はそれぞれのカテゴリがそれぞれ列を持ちます。
L 個のカテゴリを持つとき、L-1 列のみ必要で、そうでなければ、パラメータが過剰となります。
L 番目のカテゴリは参照カテゴリである必要があります。
他にも、線形回帰で使用可能な任意のエンコード方法を用いることができます。
それぞれのカテゴリの解釈はバイナリ特徴量の解釈と同様です。
- 切片$\beta_{0}$:
全ての特徴量がゼロでカテゴリカル特徴量が参照カテゴリの時、予測されるオッズの値は $\exp(\beta_{0})$ です。
切片の重みの解釈は、たいてい意味がありません。

<!--
### Example
-->
### 例

<!--
We use the logistic regression model to predict [cervical cancer](#cervical) based on some risk factors.
The following table shows the estimate weights, the associated odds ratios, and the standard error of the estimates.
-->
ここでは、ロジスティック回帰をリスク要因に基づいた[子宮頸がんの予測](#cervical)に使用します。
以下の表は推測された重み、オッズ比、予測の標準誤差を表しています。

<!--
caption='The results of fitting a logistic regression model on the cervical cancer dataset. Shown are the features used in the model, their estimated weights and corresponding odds ratios, and the standard errors of the estimated weights.'
-->

```{r logistic-example}
data("cervical")
neat_cervical_names = c('Intercept', 'Hormonal contraceptives y/n',
  'Smokes y/n', 'Num. of pregnancies',
  'Num. of diagnosed STDs',
  'Intrauterine device y/n')

# Fit logistic model for probability of cancer, use few features that are interesting
mod = glm(Biopsy ~ Hormonal.Contraceptives + Smokes + Num.of.pregnancies + STDs..Number.of.diagnosis + IUD,
  data = cervical, family = binomial())
# Print table of coef, exp(coef), std, p-value
coef.table = summary(mod)$coefficients[,c('Estimate', 'Std. Error')]
coef.table = cbind(coef.table, 'Odds ratio' = as.vector(exp(coef.table[, c('Estimate')])))
# Interpret one numerical and one factor
rownames(coef.table) = neat_cervical_names
colnames(coef.table)[1] = 'Weight'
kable(coef.table[, c('Weight', 'Odds ratio', 'Std. Error')], digits=2, caption='ロジスティック回帰モデルを子宮頸がんデータセットに適合させた結果。 モデルで使用されている特徴量、それらの推定された重みと対応するオッズ比、および推定された重みの標準誤差が示されています。')
```

<!--
Interpretation of a numerical feature ("Num. of diagnosed STDs"):
An increase in the number of diagnosed STDs (sexually transmitted diseases) changes (increases) the odds of cancer vs. no cancer by a factor of `r sprintf('%.2f', coef.table['Num. of diagnosed STDs', 'Odds ratio'])`, when all other features remain the same.
Keep in mind that correlation does not imply causation.

Interpretation of a categorical feature ("Hormonal contraceptives y/n"):
For women using hormonal contraceptives, the odds for cancer vs. no cancer are by a factor of `r sprintf('%.2f', coef.table['Hormonal contraceptives y/n', 'Odds ratio'])` lower, compared to women without hormonal contraceptives, given all other features stay the same.

Like in the linear model, the interpretations always come with the clause that 'all other features stay the same'.
-->
量的特徴量の解釈 ("Num. of diagnosed STDs"):
STDs (性感染症, sexually transmitted diseases) と診断された回数が増えると、癌かそうでないかのオッズは `r sprintf('%.2f', coef.table['Num. of diagnosed STDs', 'Odds ratio'])` 倍変化します。
ただし、他の特徴量を固定した場合です。
相関は因果関係を示しているとは限らないことに注意してください。

カテゴリカル特徴量の解釈("Hormonal contraceptives y/n"):
ホルモン避妊薬を使っている女性に関して、癌かそうでないかのオッズは、ホルモン避妊薬を使っていない人に比べて `r sprintf('%.2f', coef.table['Hormonal contraceptives y/n', 'Odds ratio'])` 倍低いです。
ただし、他の特徴量を固定した場合です。

線形モデルと同様に、解釈では常に他の特徴量が固定されているという仮定の元で行われます。

<!--
### Advantages and Disadvantages
-->
### 長所と短所

<!--
Many of the pros and cons of the [linear regression model](#limo) also apply to the logistic regression model.
Logistic regression has been widely used by many different people, but it struggles with its restrictive expressiveness (e.g. interactions must be added manually) and other models may have better predictive performance.

Another disadvantage of the logistic regression model is that the interpretation is more difficult because the interpretation of the weights is multiplicative and not additive.

Logistic regression can suffer from **complete separation**. 
If there is a feature that would perfectly separate the two classes, the logistic regression model can no longer be trained.
This is because the weight for that feature would not converge, because the optimal weight would be infinite.
This is really a bit unfortunate, because such a feature is really useful. 
But you do not need machine learning if you have a simple rule that separates both classes.
The problem of complete separation can be solved by introducing penalization of the weights or defining a prior probability distribution of weights.

On the good side, the logistic regression model is not only a classification model, but also gives you probabilities. 
This is a big advantage over models that can only provide the final classification.
Knowing that an instance has a 99% probability for a class compared to 51% makes a big difference.

Logistic regression can also be extended from binary classification to multi-class classification.
Then it is called Multinomial Regression.
-->
[線形回帰モデル](#limo)の長所と短所は、ロジスティック回帰モデルにも当てはまります。

ロジスティック回帰は様々な分野の人々によって広く使用されていますが、その表現力の低さが問題であり（たとえば、相互作用を手動で追加する必要があります）、他のモデルの方が予測性能が優れていることもあります。

ロジスティック回帰モデルのもう1つの欠点は、重みの解釈は乗法的であり、加法的ではないため、解釈が難しくなることです。

ロジスティック回帰は、**完全分離**に悩まされることがあります。
2つのクラスを完全に分離できる特徴量がある場合、ロジスティック回帰モデルは学習できなくなります。
これは、その特徴量の最適な重みが無限大となり、収束しないためです。
このような特徴量はクラス分類の際に有用なので、これは残念なことです。
しかし、このように2つのクラスを分離する単純なルールがある場合は、機械学習は必要ありません。
完全分離の問題は、重みのペナルティを導入するか、重みの事前分布を定義することで解決できます。

良い面として、ロジスティック回帰モデルは分類モデルであるだけでなく、確率を出力します。
これは、最終的な分類結果しか提供できないモデルに比べて大きな利点と言えます。
インスタンスが、あるクラスに分類される確率が51％ではなく99％であること知れるのは大きな違いがあります。

ロジスティック回帰は、2クラス分類から多クラス分類に拡張できます。
それは多項回帰 (Multinomial Regression) と呼ばれます。

<!--
### Software
-->
### ソフトウェア

<!--
I used the `glm` function in R for all examples.
You can find logistic regression in any programming language that can be used for performing data analysis, such as Python, Java, Stata, Matlab, ...
-->
上記の例は、すべて R の `glm` 関数を使用しました。
ロジスティック回帰は、Python、Java、Stata、Matlab など、データ分析に用いられるあらゆるプログラミング言語で実装されています。
